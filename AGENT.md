# AGENT ルール

AIエージェントがこのプロジェクトで作業する際の基本ルール。

## プロジェクト概要

### プロジェクト名

**KOTONOHA（コトノハ）** - 場面緘黙自助グループ運営支援 Discord bot

### 目的

場面緘黙自助グループの Discord サーバー運営を支援するため、AI 機能を統合した Discord botを開発する。ユーザーが安心して対話できる環境を提供し、コミュニティの活性化と相互支援を促進する。

### 技術スタック

| カテゴリ | 技術 | 用途 |
|---------|------|------|
| **言語** | Python 3.14 | アプリケーション開発 |
| **パッケージ管理** | uv | 依存関係管理 |
| **フレームワーク** | discord.py | Discord Bot 開発 |
| **AI API** | Claude API (LiteLLM 経由) | AI 応答生成 |
| **データベース** | PostgreSQL + pgvector | 会話履歴の永続化、ベクトル検索 |
| **コンテナ** | Docker | コンテナ化 |
| **CI/CD** | GitHub Actions | 自動ビルド・デプロイ |
| **レジストリ** | GitHub Container Registry | イメージ保存 |
| **自動更新** | Watchtower | コンテナ自動更新 |

**AI モデル**:

- **デフォルトモデル**: Claude Opus 4.5（`anthropic/claude-opus-4-5`）
- **判定用モデル**: Claude Haiku 4.5（`anthropic/claude-haiku-4-5`、聞き耳型の判定に使用）
- **Embedding**: OpenAI text-embedding-3-small（知識ベース用）

### 主要機能

1. **チャット応答機能**: ユーザーのメッセージに対して AI が自然で安心感のある応答を生成
2. **会話の契機（3 つの方式）**:
   - **メンション応答型**: Bot にメンションされた時だけ反応
   - **スレッド型**: メンション時に自動でスレッドを作成し会話継続
   - **聞き耳型**: LLM で適切なタイミングを判断して自然に会話に参加
3. **会話履歴管理**: PostgreSQL による永続化とセッション管理
4. **知識ベース**: セッションアーカイブとベクトル検索による長期記憶機能
5. **レート制限**: トークンバケットアルゴリズムとリクエストキューで管理
6. **スラッシュコマンド**: `/chat reset`, `/chat status` など
7. **ヘルスチェック**: HTTP エンドポイントによる稼働状況確認

---

## 最優先指令

1. **ユーザーの利益と安全を最優先せよ**: 破壊的な操作（データ削除、本番環境への変更、不可逆なマイグレーション等）を行う際は、必ず実行前にユーザーの明確な承認を得ること
2. **コード品質を妥協するな**: 常に可読性が高く、テスト可能で、保守しやすいコードを維持すること
3. **文脈を理解し、自律的に動け**: 指示待ちにならず、必要な情報は自らファイルを確認して取得すること。ただし、判断に迷う際は必ず質問すること

---

## 1. 一般規約

### 1.1 応答言語

必ず日本語で回答する。
たとえ英語のプロンプトであっても、日本語で応答する。

### 1.2 文体

「である調」（常体）で統一する。「です・ます調」（敬体）は使用しない。

| 使用する表現 | 避ける表現 |
|-------------|-----------|
| 〜である | 〜です |
| 〜とする | 〜とします |
| 〜できる | 〜できます |
| 〜すること | 〜してください |

箇条書きには体言止めを使う。

自然で簡潔な表現を使う。AI臭い冗長な修飾表現は避ける。

| 避ける表現 | 推奨する表現 |
|-----------|------------|
| 〜することができる | 〜できる |
| 〜することが可能である | 〜できる |
| 〜となる | 〜になる / 〜である |
| 〜させていただきます | 〜する |
| 〜いたします | 〜する |
| 〜することができます | 〜できる |
| 〜することが可能です | 〜できる |
| 〜となります | 〜になる / 〜である |
| 〜ですので | 〜なので / 〜であるため |

```markdown
# ❌ 悪い例（AI臭い表現）

この機能を使用することで、ユーザーは効率的にデータを処理することが可能となります。
また、この機能は非常に便利な機能となっており、多くの場面で活用していただくことができます。

# ✅ 良い例（自然な表現）

この機能でデータを効率的に処理できる。
多くの場面で活用できる。
```

### 1.3 テスト

- 新機能にはテストを書く
- バグ修正時は再発防止のテストを追加する
- テストは `uv run pytest` で実行

### 1.4 依存関係の管理

- 依存関係の追加は `uv add <package>` を使用
- 不要な依存関係は追加しない
- 追加時はセキュリティとメンテナンス状況を確認する
- 不要になったパッケージは逐次削除する（`uv remove <package>` を使用）

#### pyproject.toml の活用

新機能の実装や問題解決の際は、`pyproject.toml` に記載されている既存のライブラリを優先的に活用する。

- **既存ライブラリの確認**: 新しいライブラリを追加する前に、`pyproject.toml` の `dependencies` を確認し、既存のライブラリで要件を満たせるか検討する
- **バージョン情報の参照**: 既存ライブラリのバージョンを確認し、そのバージョンに適したAPIの使い方を提案する
- **開発ツール設定の理解**: `[tool.ruff]`、`[tool.ty]`、`[tool.pytest.ini_options]` などの設定を確認し、プロジェクトのコーディング規約やテスト設定に従う
- **重複実装の回避**: 既存ライブラリで提供されている機能を再実装しない

### 1.5 破壊的変更

既存のAPIや動作を変更する場合：

- 影響範囲を事前に確認する
- 必要に応じて移行パスを用意する
- CHANGELOGに明記する

### 1.6 機密情報

APIキー、パスワード、トークン等の機密情報はコミットしない。

- `.env` ファイルは `.gitignore` に含める
- 環境変数や設定ファイルに機密情報を含めない
- 必要に応じて `.env.example` を用意し、実際の値は含めない

---

## 2. コーディング規約

### 2.1 開発ツール

プロジェクトの実行は `uv run` を使用する。

| ツール | 用途 | コマンド |
|-------|------|---------|
| ruff | フォーマット | `uv run ruff format .` |
| ruff | リント | `uv run ruff check .` |
| ty | 型チェック | `uv run ty src/` |

tyはAstral製の高速な型チェッカー（mypyやpyrightの代替）。

### 2.2 コミット前の必須確認

コード変更後は以下をすべて実行し、エラーがない状態でコミットする。

```bash
uv run ruff format .
uv run ruff check .
uv run ty src/
```

### 2.3 コミットメッセージ

Gitのコミットメッセージを生成または提案する際は、以下のルールを厳守する。

#### 基本ルール

1. **言語**: 必ず「日本語」で記述する。
2. **文体**: 簡潔で分かりやすい表現にする（「〜を修正」「〜を追加」など）。

#### フォーマット (Conventional Commits)

`<type>: <description>` の形式を使用する。

##### Type 一覧

- `feat`: 新機能の追加
- `fix`: バグ修正
- `docs`: ドキュメントのみの変更
- `style`: コードの動作に影響しない変更（空白、フォーマットなど）
- `refactor`: バグ修正や機能追加を含まないコードの変更（リファクタリング）
- `perf`: パフォーマンスを向上させる変更
- `test`: テストの追加や修正
- `chore`: ビルドプロセスやツールの変更

#### 例

```txt
# ❌ 悪い例
update code (英語は禁止)
修正しました (具体的でない)
fix: Fixed logic (英語が混ざっている)

# ✅ 良い例
feat: ユーザーログイン機能を追加
fix: 検索画面で発生するレイアウト崩れを修正
refactor: ユーザーモデルのバリデーションロジックを整理
```

### 2.4 コメントは日本語で記述

- 行コメント、docstringはすべて日本語
- 絵文字は使わない
- 自明なコードに不要なコメントは書かない
- 複雑なロジックや設計判断の理由を説明する

docstringの変数説明には体言止めを使う。

ただし、コンソールやターミナルに出力されるメッセージ（`print()`、ログメッセージ、エラーメッセージなど）は英語のみとする。

```python
# ❌ 悪い例
def process_input(data: str) -> bool:
    """Validate user input."""
    return len(data) > 0

# ✅ 良い例
def fetch_user(user_id: int) -> User:
    """ユーザー情報を取得する。

    Args:
        user_id: 対象ユーザーのID

    Returns:
        取得したユーザーオブジェクト
    """
```

### 2.5 命名規則

| 対象             | 規則                | 例                          |
| ---------------- | ------------------- | --------------------------- |
| モジュール       | snake_case          | `user_service.py`           |
| クラス           | PascalCase          | `UserRepository`            |
| 関数・メソッド   | snake_case          | `get_user_by_id`            |
| 定数             | UPPER_SNAKE_CASE    | `MAX_RETRY_COUNT`           |
| プライベート     | _prefix             | `_internal_method`          |
| 型変数           | PascalCase + T      | `ItemT`, `ResponseT`        |

### 2.6 エラー対応

エラーが発生した際は、手当たり次第に部分最適化して対症療法的に解決するのではなく、根本的な解決を目指し、全体最適化を行う。

#### 基本方針

1. **根本原因の分析を優先**

   - エラーの表面的な症状に飛びつかず、まず根本原因を特定する
   - エラーが発生している箇所だけでなく、関連する全体の設計やアーキテクチャを考慮する
   - なぜそのエラーが発生するのか、システム全体の文脈で理解する
   - プロジェクトの実行フローをよく精査し、各ファイルに不具合がないか1つずつ確認していく

2. **全体最適化の視点**

   - 部分的な修正で一時的に問題を隠すのではなく、システム全体の整合性を保つ解決策を選択する
   - 修正が他の部分に与える影響を考慮し、副作用を最小限に抑える
   - 長期的な保守性と拡張性を重視する
   - 部分最適化でコードが複雑化していくのはナンセンスである

3. **既存ロジックの保護**

   - **既存のロジックや機能は全く変えずに**、根本的な解決を目指すこと
   - 既存の動作を壊さない範囲で、新しいアプローチや設計を導入する
   - 後方互換性を維持しながら、より良い設計へと進化させる

4. **対症療法の回避**
   - エラーメッセージを無理やり回避するような修正は行わない
   - エラーを握りつぶしたり、例外を広くキャッチして無視するような実装は避ける
   - 一時的な回避策ではなく、根本的な解決策を実装する
   - 警告やノートを抑制する設定を追加することは禁止する

#### エラー処理

適切なエラーメッセージを出力し、エラーを握りつぶさない。

```python
# ❌ 悪い例
try:
    result = some_function()
except Exception:
    result = None  # エラーを無視

# ✅ 良い例
if not is_valid_input(data):
    raise ValueError(f"無効な入力: {data}")
result = some_function(data)
```

#### ログ記録規則

- 例外発生時は必ずログを記録する
- ログレベルは適切に使い分ける（DEBUG / INFO / WARNING / ERROR / CRITICAL）
- 機密情報（パスワード、トークン等）はログに出力しない

#### 警告への対応

警告は問題の兆候である。抑制するのではなく、根本的な解決を目指す。

- 警告（Warning）やノート（Note）を抑制する設定の追加は禁止する
- `filterwarnings` や `-W ignore` による警告の無視は禁止する
- リンターや型チェッカーの警告を無視する設定は禁止する
- 外部ライブラリからの警告であっても、抑制するのではなく、ライブラリの更新や代替手段を検討する

```toml
# ❌ 禁止
[tool.pytest.ini_options]
filterwarnings = ["ignore::DeprecationWarning"]
```

#### チェックリスト

エラー対応時に以下を確認する：

- [ ] エラーの根本原因を特定したか
- [ ] システム全体の文脈で問題を理解したか
- [ ] 既存のロジックを変更せずに解決できるか
- [ ] 対症療法ではなく、根本的な解決策を実装しているか
- [ ] 他の部分への副作用を考慮したか
- [ ] 長期的な保守性を考慮したか
- [ ] ruff のフォーマットとリンターが通るか（`uv run ruff format .` と `uv run ruff check .`）
- [ ] ty の型チェックが通るか（`uv run ty src/`）
- [ ] ドキュメントを更新した場合、すべての相互リンクが正確に保たれているか
- [ ] 警告などを抑制する設定を追加していないか

---

## 3. ドキュメント規約

### 3.1 相互リンクの管理

すべてのドキュメントファイルは、更新のたびに互いの相互リンクが正確に保たれているか確認する。

#### リンクの整合性確認

- ドキュメントを更新・追加・削除した際は、必ず関連するすべてのドキュメントのリンクを確認する
- リンク切れや、存在しないファイルへのリンクがないか確認する
- ファイル名やパスが変更された場合は、すべての参照箇所を更新する

#### 確認すべき項目

- Markdownファイル内の相対パスリンク（`[テキスト](./path/to/file.md)`）
- README.mdや目次ファイルからのリンク
- 関連ドキュメント間の相互参照
- セクションへのアンカーリンク（`#section-name`）

#### 更新時の確認手順

ドキュメントを変更した後、以下を確認する：

- 変更したファイルから参照している他のドキュメントのリンクが有効か
- 他のドキュメントから変更したファイルへのリンクが有効か
- ファイル名やディレクトリ構造を変更した場合、すべての参照を更新したか
- リンク切れを発見した場合は、即座に修正する

### 3.2 ドル記号のエスケープ

料金表記では `$` を `\$` にエスケープする（数式記号との混同を避けるため）。

```markdown
# ❌ 悪い例
| Sonnet | $3/input MTok |

# ✅ 良い例
| Sonnet | \$3/input MTok |
```
