# 「同じ会話」の定義

## 現在の実装

現在の実装では、**「同じ会話 = 同じチャンネル」**として定義されています。

### 実装の詳細

```python
def _should_allow_intervention(self, channel_id: int) -> bool:
    # チャンネルIDごとに介入履歴を管理
    # 30分以内の介入回数をチェック
    # 最後の介入から10分経過していない場合は介入しない
```

**現在の定義**:

- **同じチャンネル = 同じ会話**
- チャンネル ID ごとに介入履歴を追跡
- 30 分以内の介入回数をチェック（デフォルト: 2 回まで）
- 最後の介入から 10 分経過していない場合は介入しない

## 問題点

1. **異なるトピックの会話が混在する可能性**

   - 同じチャンネルで、異なるトピックの会話が続く可能性がある
   - 例: イベント運営の話 → 別の話題 → またイベント運営の話
   - この場合、別の会話として扱うべきだが、現在は「同じ会話」として扱われる

2. **時間が経過した後の会話**

   - 時間が経過（例：1 時間以上）すれば、別の会話として扱うべき
   - 現在は 1 時間以内の履歴を保持しているが、30 分以内の介入回数で判定している

3. **会話の自然な終了を考慮していない**
   - 会話が自然に終了した後、新しい会話が始まった場合を区別できていない

## 改善案

### 案 1: 時間ベースの定義（推奨・シンプル）

**定義**: 一定時間（例：30 分）以内の連続した会話を「同じ会話」とする

**実装**:

- メッセージ間の時間間隔が長い（例：30 分以上）場合は、別の会話として扱う
- 介入履歴を時間ベースで管理し、30 分以内の介入回数をチェック

**メリット**:

- シンプルで実装が容易
- オーバーフィッティングを避けられる
- 一般的な原則に基づく

**デメリット**:

- 同じトピックでも時間が経過すれば別の会話として扱われる
- 短時間で異なるトピックの会話が続く場合を区別できない

### 案 2: メッセージ間隔ベースの定義

**定義**: メッセージ間の時間間隔が長い（例：1 時間以上）場合は別の会話とする

**実装**:

- 最新のメッセージのタイムスタンプを記録
- メッセージ間の時間間隔が長い場合は、介入履歴をリセット

**メリット**:

- 会話の自然な終了を検知できる
- 時間が経過した後の会話を別の会話として扱える

**デメリット**:

- 実装がやや複雑
- メッセージのタイムスタンプを追跡する必要がある

### 案 3: ハイブリッド定義（時間 + メッセージ間隔）

**定義**:

- 30 分以内の連続した会話を「同じ会話」とする
- メッセージ間の時間間隔が長い（例：1 時間以上）場合は、別の会話として扱う

**実装**:

- 介入履歴に、最新のメッセージのタイムスタンプも記録
- メッセージ間の時間間隔が長い場合は、介入履歴をリセット
- 30 分以内の介入回数をチェック

**メリット**:

- 時間ベースとメッセージ間隔ベースの両方の利点を活かせる
- より正確な「同じ会話」の判定が可能

**デメリット**:

- 実装がやや複雑
- メッセージのタイムスタンプを追跡する必要がある

## 推奨される改善

**案 1（時間ベースの定義）を推奨**します。理由：

1. **シンプルで実装が容易**

   - 現在の実装に近く、変更が少ない
   - オーバーフィッティングを避けられる

2. **一般的な原則に基づく**

   - 特定の会話パターンに特化しない
   - 柔軟性が高い

3. **実用的**
   - ほとんどの場合で適切に動作する
   - 過度に複雑な実装を避けられる

## 実装例（案 1）

```python
def _should_allow_intervention(
    self, channel_id: int, recent_messages: list[discord.Message]
) -> bool:
    """介入が許可されるか判定（過度な介入を防ぐ）

    定義: 30分以内の連続した会話を「同じ会話」とする
    """
    now = datetime.now()

    # チャンネルの介入履歴を取得
    if channel_id not in self.intervention_history:
        return True

    history = self.intervention_history[channel_id]

    # 古い履歴を削除（30分以上前の介入は無視 = 別の会話）
    cutoff_time = now - timedelta(minutes=30)
    history[:] = [t for t in history if t > cutoff_time]

    # 注意: 現在の実装では、介入回数や時間間隔のチェックはLLM判定に委ねられています
    # この実装例は参考用です

    return True
```

## 現在の実装との違い

| 項目                   | 現在の実装                 | 改善案（案 1）          |
| ---------------------- | -------------------------- | ----------------------- |
| 同じ会話の定義         | 同じチャンネル             | 30 分以内の連続した会話 |
| 介入履歴の保持期間     | 1 時間                     | 30 分                   |
| 介入回数のチェック期間 | 30 分                      | 30 分（同じ）           |
| 別の会話の判定         | チャンネルが異なる場合のみ | 30 分以上経過した場合   |

## 実装された改善（LLM 判定）

**最終的な実装**: LLM で「同じ会話かどうか」を判定する方式を採用しました。

### LLM 判定方式の実装詳細

1. **介入履歴に会話ログを保存**

   - 介入時に、最新の 5 メッセージの会話ログを保存
   - チャンネル ID ごとに、`(介入時刻, 会話ログ)`のリストを管理

2. **LLM で「同じ会話かどうか」を判定**

   - 前回の介入時の会話と、現在の会話を比較
   - LLM に「SAME」または「DIFFERENT」で判定させる
   - トピック、参加者、時間的な連続性、会話の文脈を総合的に判断

3. **判定結果に応じた処理**
   - **同じ会話の場合**: 介入回数をチェック（30 分以内に 2 回まで）
   - **別の会話の場合**: 介入履歴をリセット（新しい会話として扱う）

### メリット

1. **柔軟な判定**

   - 会話の内容を分析し、機械的なルールに依存しない
   - トピックが同じでも時間が経過していれば別の会話として扱える
   - トピックが異なれば、時間が短くても別の会話として扱える

2. **オーバーフィッティングを避ける**

   - 一般的な原則（トピック、文脈、参加者）に基づく判定
   - 特定の会話パターンに特化しない
   - プロンプトで一般的な判断基準を指示

3. **実用的**
   - 時間ベースの判定も併用（最小間隔チェック）
   - エラー時は安全側に倒す（同じ会話として扱う）

### プロンプト設計

`prompts/eavesdrop_same_conversation_prompt.md`で、以下の判断基準を指示：

- **SAME**: トピックが同じ/関連、参加者が同じ/重複、時間的な連続性、会話の文脈が続いている
- **DIFFERENT**: トピックが全く異なる、時間的な間隔が長い、会話の文脈が切れている、参加者が大きく変わっている

**優先順位**: トピックと内容の関連性 > 会話の文脈の連続性 > 時間的な間隔、参加者の変化

## 結論

**実装された改善**: LLM で「同じ会話かどうか」を判定する方式を採用しました。

これにより、以下の問題が解決されます：

1. ✅ 異なるトピックの会話を区別できる
2. ✅ 時間が経過した後の会話を適切に判定できる
3. ✅ 会話の内容と文脈を考慮した柔軟な判定が可能

機械的なルールに依存せず、会話の内容を分析して適切に「同じ会話かどうか」を判定できるようになりました。
