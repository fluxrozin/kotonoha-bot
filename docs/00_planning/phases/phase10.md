# Phase 10: 完全リファクタリング

Kotonoha Discord Bot の Phase 10（完全リファクタリング）の基本方針と概要

**作成日**: 2026年1月19日  
**バージョン**: 2.0  
**作成者**: kotonoha-bot 開発チーム

---

## 目次

1. [エグゼクティブサマリー](#1-エグゼクティブサマリー)
2. [目標とスコープ](#2-目標とスコープ)
3. [前提条件](#3-前提条件)
4. [現状分析](#4-現状分析)
5. [リファクタリング方針](#5-リファクタリング方針)
6. [新しいフォルダ構造](#6-新しいフォルダ構造)
7. [実装ステップ概要](#7-実装ステップ概要)
8. [完了基準](#8-完了基準)
9. [リスク管理概要](#9-リスク管理概要)
10. [詳細実装計画へのリンク](#10-詳細実装計画へのリンク)

---

## 1. エグゼクティブサマリー

### 1.1 目的

機能や仕様を一切変更せず、コードベースの品質向上と技術的負債の解消、さらなる機能追加のやりやすさを実現することを目的とする。移行方式はビックバン移行を目標とする。後方互換性は不要であり、完全リファクタリング・ゼロから作り直しを前提とする。

### 1.2 スコープ

**リファクタリング対象**:

- `src/kotonoha_bot/`
- `tests/`
- `.env.example`
- `docs/`
- `alembic/`, `alembic.ini`
- `scripts/`
- `pyproject.toml`
- `Dockerfile`, `docker-compose.yml`
- `README.md`

### 1.3 主要な改善項目

| 項目 | 現状 | 目標 |
|------|------|------|
| handlers.py | 832行（単一ファイル） | 物理分割（handlers/パッケージ化） |
| 重複コード | 6箇所以上 | 0箇所 |
| 設定管理 | main.py にログ設定混在 | core/config.py に統合 |
| エラーメッセージ | 各所に散在 | errors/messages.py に一元管理 |
| テスト構造 | フラット | ソース構造に対応 |
| 型ヒント | 部分的 | 100%カバレッジ |

### 1.4 実装期間

約 10-15 日

### 1.5 設計方針

**1人開発に適したシンプルな構造を維持**:

- ディレクトリ深度は最大2階層
- 1ファイル800-1000行は許容（超えたら分割検討）
- 関連コードは近くに配置（ファイル間の行き来を減らす）
- 過度な抽象化を避ける

---

## 2. 目標とスコープ

### 2.1 目標

**コードベースの品質向上と技術的負債の解消を実現する**

**達成すべきこと**:

1. **コード構造の整理**: モジュール構造の最適化、循環参照の解消、責務の明確化
2. **アーキテクチャの改善**: 設計パターンの適用、依存性注入の改善、エラーハンドリングの統一
3. **パフォーマンス最適化**: データベースクエリの最適化、メモリ使用量の最適化、非同期処理の最適化
4. **コード品質の向上**: 型ヒントの完全化、ドキュメントの充実、コードスタイルの統一
5. **テストの充実**: テストカバレッジの向上、テストの品質向上
6. **重複コードの削除**: 日付フォーマット、プロンプト読み込み、エラーメッセージの一元管理

**注意**: 機能や要件、使用は一切変更しないこと。リファクタリングのみを実施する。

### 2.2 スコープ

#### 含まれるもの

- フォルダ構造の再編成
- ファイルの移動と統合
- handlers.py の物理分割
- 重複コードの削除
- 依存性注入パターンの適用
- 型ヒントとdocstringの追加
- テスト構造の整理
- 例外のラッピング（抽象化の徹底）
- Config のインスタンス化
- 終了処理（Graceful Shutdown）の実装
- 外部ライブラリの更新・活用（`pyproject.toml` で利用可能な新しいライブラリの積極的な活用）
- ドキュメント内のファイルパス参照と内容の更新（`docs/` 内の全ファイル）
  - ファイルパス参照の更新
  - プロジェクト構成の説明内容の更新（フォルダ構造変更の反映）

#### 含まれないもの

- 新機能の追加
- 既存機能の仕様変更
- データベーススキーマの変更

---

## 3. 前提条件

### 3.1 実装前の確認事項

- ✅ **Phase 7（aiosqlite への移行）が完了していること**
- ✅ **Phase 8（PostgreSQL への移行）が完了していること**
- ✅ すべてのテストが通過していること
- ✅ 既存の機能が正常に動作していること

### 3.2 必要な知識・スキル

- Python 3.14 の型ヒント機能
- 非同期プログラミング（asyncio）
- 設計パターン（依存性注入、ファクトリーパターンなど）
- テスト駆動開発（TDD）の理解
- リファクタリング手法

---

## 4. 現状分析

### 4.1 現在の構造の問題点

**主な問題点**:

- `handlers.py` が 832 行と大きすぎる（単一責任の原則違反）
- `config.py` がすべての設定を管理（責務が多すぎる）
- `main.py` にログ設定が含まれている（関心の分離違反）
- レイヤーが明確でない（プレゼンテーション層、アプリケーション層、データアクセス層の区別が不明確）
- エラーハンドリングが分散している
- 重複コードが存在（日付フォーマット、プロンプト読み込み、エラーメッセージ）

### 4.2 コード品質の問題

- 型ヒントが完全ではない箇所がある
- docstring が不足している箇所がある
- 循環参照の可能性がある
- 依存性注入が不十分（直接インスタンス化が多い）

**詳細な現状分析は [実装ガイド](./phase10-implementation.md#2-現状分析) を参照してください。**

---

## 5. リファクタリング方針

### 5.1 設計原則

1. **単一責任の原則（SRP）**: 各クラス・モジュールは 1 つの責務のみを持つ
2. **依存性逆転の原則（DIP）**: 抽象に依存し、具象に依存しない
3. **関心の分離（SoC）**: 各レイヤーは独立した責務を持つ
4. **DRY 原則**: 重複コードを削除
5. **KISS 原則**: シンプルに保つ

### 5.2 基本方針

- **1ファイルだけのディレクトリは統合する**（router/ → bot/）
- **832行の handlers.py は分割必須**（bot/handlers/ 内で分割）
- **重複コードを統一**（日付、プロンプト読み込み、エラーメッセージ）
- **ディレクトリ増は避ける**（新規ディレクトリ作成は最小限）

### 5.3 リファクタリングテクニック

リファクタリング実施時は、以下のテクニックを積極的に活用する。

#### A. メソッドの構成法（基本中の基本）

**メソッドの抽出 (Extract Method)**:

長いコードの一部を切り出し、別のメソッドにする。

- **効果**: コードの意図が名前から読み取れるようになり、再利用性が高まる
- **適用例**: `handlers.py` 内の長い処理ロジックを独立したメソッドに分割

**変数のインライン化 (Inline Temp)**:

一度しか使われない一時変数を削除し、直接式を記述する。

- **効果**: 余計な変数が減り、メソッド抽出がしやすくなる
- **適用例**: 中間変数を削除してメソッド抽出の準備を行う

#### B. オブジェクト間の特性の移動

**メソッドの移動 (Move Method)**:

メソッドが、定義されているクラスよりも別のクラスのデータを頻繁に使っている場合、そのメソッドを「もっとも使っているクラス」へ移動させる。

- **効果**: 結合度（Coupling）を下げ、凝集度（Cohesion）を高める
- **適用例**: `handlers.py` 内のセッション管理ロジックを `SessionManager` に移動

#### C. 条件記述の簡素化（中級テクニック）

**条件記述の分解 (Decompose Conditional)**:

複雑な条件式を、意味のあるメソッド名に抽出する。

```python
# Before
if date.before(SUMMER_START) || date.after(SUMMER_END):
    # ...

# After
if not_summer(date):
    # ...
```

- **効果**: 条件の意図が明確になり、可読性が向上する
- **適用例**: `message_router.py` の複雑な条件判定をメソッドに抽出

**条件記述のポリモーフィズムへの置き換え (Replace Conditional with Polymorphism)**:

タイプコードによる switch 文がある場合、それをクラスの継承構造やインターフェース（State/Strategyパターン）に置き換える。

- **効果**: 新しいタイプを追加する際に、既存コード（switch文）を修正せず、新しいクラスを追加するだけで済むようになる（オープン・クローズドの原則）
- **適用例**: メッセージタイプによる分岐処理をポリモーフィズムで実装

#### D. データの構成

**マジックナンバーの記号定数への置き換え**:

ソースコードに直接書かれた数字を、意味のある定数に置き換える。

```python
# Before
timeout = 86400  # 何の値か不明

# After
SECONDS_IN_DAY = 86400
timeout = SECONDS_IN_DAY
```

- **効果**: コードの意図が明確になり、保守性が向上する
- **適用例**: タイムアウト値、リトライ回数、バッファサイズなどを定数化

**値オブジェクトの導入 (Introduce Value Object)**:

常に一緒に扱われるデータをクラス（構造体）としてまとめる。

- **効果**: データの整合性が保たれ、意図しない値の組み合わせを防げる
- **適用例**: 「氏名（姓・名）」「金額（数値・通貨）」「日時情報（日付・時刻・曜日）」などを値オブジェクト化

### 5.4 安全装置としてのテスト駆動

技術的なリファクタリングにおいて最も重要なルールは、**「テストがないコードはリファクタリングしてはいけない」**ということである。

#### リファクタリングの安全な手順

1. **テストを書く**: 現状の挙動を保証する自動テスト（単体テスト）を用意する
2. **リファクタリング**: コード構造を少し変える
3. **テスト実行**: テストが通ることを確認する（振る舞いが変わっていないことの証明）
4. **コミット**: 小さな単位でこまめにコミットする

#### 重要な原則

**「テストがないコードはリファクタリングしない」の適用**:

Phase 9 は全体をリファクタリングするため、リファクタリング対象のコードにテストがない場合は、まずテストを書く必要がある。
これにより、リファクタリング前の挙動を保証する安全網を構築し、リファクタリング後の挙動が変わっていないことを確認できる。

- **リファクタリング対象コードのテストを整備**: リファクタリング対象となる既存コードにテストがない場合、リファクタリング開始前にテストを書く
- **小さな変更を繰り返す**: 大きな変更を一度に行わず、小さな変更を繰り返してテストを実行する
- **テストが通ることを確認**: 各変更後に必ずテストを実行し、振る舞いが変わっていないことを確認する
- **こまめにコミット**: テストが通る状態を小さな単位でコミットし、問題が発生した場合に戻りやすくする

#### Phase 9 での適用

- **Step 0 でテストを整備**: リファクタリング開始前に、リファクタリング対象のコードにテストがない場合は、まずテストを書く作業から始める
- **各ステップ完了時にテストを実行**: Step 0-8 の各ステップ完了時に必ず全テストを実行する
- **既存テストの維持**: 既存のテストがすべて通過することを確認する
- **テストカバレッジの確認**: リファクタリング対象のコードがテストでカバーされていることを確認する

**詳細なリファクタリング方針とアーキテクチャパターンは [実装ガイド](./phase10-implementation.md#4-リファクタリング方針) を参照してください。**

---

## 6. 新しいフォルダ構造

### 6.1 主な変更点

1. **レイヤーの簡略化**: `bot/`, `services/`, `data/`, `features/`, `external/`, `core/` の 6 層
2. **handlers.py の分割**: 832 行 → `mention.py`, `thread.py`, `eavesdrop.py` に分割（必須）
3. **設定管理の整理**: `config.py` → `core/config.py` に移動、クラスで整理（1 ファイル）
4. **ログ設定の分離**: `main.py` から `core/logging.py` に分離
5. **エラーハンドリングの統一**: `errors/` → `features/errors/` に移動、`messages.py` で一元管理
6. **重複コードの削除**: 日付フォーマット、プロンプト読み込み、エラーメッセージを統一
7. **router/ の統合**: `router/message_router.py` → `bot/router.py` に移動

### 6.2 ファイル数の比較

| 項目                   | 現在                | リファクタリング後        |
| ---------------------- | ------------------- | ------------------------- |
| **Pythonファイル数**   | 44 ファイル          | 45 ファイル (+1)          |
| **ディレクトリ数**     | 13 ディレクトリ      | 8 ディレクトリ (-5)       |
| **handlers.py 分割**   | 1 ファイル (890 行)  | 4 ファイル（分割）        |
| **重複コード削除**     | 6+ 箇所             | 0 箇所                    |

**詳細なフォルダ構造とファイル移動マッピングは [実装ガイド](./phase10-implementation.md#5-新フォルダ構造) を参照してください。**

---

## 7. 実装ステップ概要

### 7.1 ステップ一覧

| Step | 内容 | 期間 |
|------|------|------|
| 0 | 依存方向の確定（循環参照の防止） | 0.5日 |
| 1 | 重複コード削除（utils/datetime.py, errors/messages.py） | 0.5日 |
| 2 | ファイル統合と移動 + Config インスタンス化 | 1.5日 |
| 3 | handlers.py 物理分割（DIパターン適用） | 1.5日 |
| 4 | services/ai.py の戻り値変更 + 例外ラッピング | 1日 |
| 5 | インポートパス更新と動作確認 | 1日 |
| 6 | テスト構造の整理（aiosqlite フィクスチャ + ファクトリー） | 1.5日 |
| 7 | 型ヒント・docstring 追加 | 1日 |
| 8 | 終了処理（Graceful Shutdown）の実装 | 0.5日 |
| **合計** | | **9日** |

**各ステップの詳細な実装手順、コード例、コーディング規約は [実装ガイド](./phase10-implementation.md#6-詳細実装計画) を参照してください。**

---

## 8. 完了基準

### 8.1 必須項目

#### コード構造

- [ ] 全ての重複コードが削除されている
- [ ] 新フォルダ構造に移行完了
- [ ] 不要なディレクトリが削除されている

#### コード品質

- [ ] 全ファイルに型ヒントが 100% 適用
- [ ] 全公開 API に docstring が存在
- [ ] `ruff check` が警告なしで通過
- [ ] `ruff format --check` が通過
- [ ] `ty` による型チェックが通過

#### テスト

- [ ] 全テストが通過（既存 137 + 新規）
- [ ] テストカバレッジ 80% 以上
- [ ] テスト構造がソースコード構造と対応

#### 機能

- [ ] 既存の全機能が正常動作（回帰テスト）
- [ ] services/ai.py の戻り値が `tuple[str, TokenInfo]`

### 8.2 品質基準

- **型安全性**: `ty` による型チェックが通過する
- **コードスタイル**: `ruff check` が警告なしで通過する
- **テストカバレッジ**: 80% 以上
- **ドキュメント**: すべての公開 API に docstring が存在する

**詳細なチェックリストと品質チェックコマンドは [実装ガイド](./phase10-implementation.md#8-完了基準とチェックリスト) を参照してください。**

---

## 9. リスク管理概要

### 9.1 主要なリスク

| リスク | 影響度 | 発生確率 | 対策 |
|--------|--------|----------|------|
| 回帰バグ | 高 | 中 | 各 Step で全テスト実行 |
| インポートエラー | 中 | 高 | 段階的移行、`__init__.py` での再エクスポート |
| テストの壊れ | 中 | 中 | テストも同時に移行 |
| 予想外の依存関係 | 中 | 低 | 事前の依存関係分析 |
| 非同期DBテストの複雑性 | 中 | 中 | テストごとのDB状態リセット、適切なフィクスチャ設計 |
| 循環参照（循環インポート） | 高 | 中 | 依存の方向性を厳格に定義、TYPE_CHECKING の活用 |
| 初期化順序の不備 | 高 | 中 | 初期化順序の明確化、main.py での明示的な初期化 |

### 9.2 ロールバック戦略

1. **Git ブランチ戦略**
   - `feature/phase9-refactoring` ブランチで作業
   - 各 Step 完了時にコミット
   - 問題発生時は直前のコミットに戻す

2. **段階的マージ**
   - Step 1-3 完了後に中間レビュー
   - Step 4-7 完了後に中間レビュー
   - 全 Step 完了後に最終レビュー

**詳細なリスク管理、ロールバック戦略、テスト戦略は [実装ガイド](./phase10-implementation.md#9-リスク管理) を参照してください。**

---

## 10. 詳細実装計画へのリンク

このドキュメントは Phase 9 の基本方針と概要を説明しています。

**詳細な実装手順、コード例、コーディング規約については、以下のドキュメントを参照してください：**

- **[Phase 10 実装ガイド](./phase10-implementation.md)**: 各ステップの詳細な実装手順、コード例、コーディング規約、テスト戦略

### 10.1 詳細実装計画の内容

詳細実装計画には以下の内容が含まれています：

1. **コーディング規約**: 命名規則、型ヒント規約、docstring 規約、インポート規約、エラーハンドリング規約、ログ規約、非同期規約
2. **詳細実装計画**: 各ステップ（Step 0-8）の詳細な実装手順とコード例
3. **テストコードリファクタリング**: テスト構造の詳細、テストファイル移動マッピング、テストデータファクトリー
4. **完了基準とチェックリスト**: 詳細なチェックリスト、品質チェックコマンド
5. **リスク管理**: リスク一覧、ロールバック戦略、テスト戦略、非同期DBテストの複雑性、循環参照のリスク、初期化順序のリスク

---

## 11. 重要な変更点

### 11.1 AI プロバイダーの移行（LiteLLM → Anthropic SDK）

**Phase 9 のリファクタリング時に実施**:

[ADR-0011](../20_architecture/22_adrs/0011-remove-litellm-direct-sdk.md) により、LiteLLM を削除し、Anthropic SDK を直接使用するように変更します。

**変更内容**:

- `LiteLLMProvider` → `AnthropicProvider` に置き換え
- `litellm` パッケージを削除、`anthropic` パッケージを追加
- `generate_response()` の戻り値を `tuple[str, dict]` に変更し、トークン情報も返すようにする

**理由**:

- Phase 13（コスト管理）と Phase 14（監査ログ）でトークン情報が必要
- 実際の使用状況（プロバイダー固定）との整合性
- LiteLLM のデメリット（パフォーマンス、セキュリティ、オーバーヘッド）の回避

**詳細**: [実装ガイド - Step 4](./phase10-implementation.md#65-step-4-servicesaipy-の戻り値変更--例外ラッピング1日)

### 11.2 例外のラッピング（抽象化の徹底）

Handler層が具体的なライブラリの例外を知っている必要があるのは抽象化の漏れ（Leaky Abstraction）です。
将来AIライブラリを変える際にHandlerも修正が必要になります。

**対策**: `errors/ai.py` で独自例外を定義し、`services/ai.py` で Anthropic SDK の例外を独自例外にラッピングします。

**詳細**: [実装ガイド - Step 4](./phase10-implementation.md#65-step-4-servicesaipy-の戻り値変更--例外ラッピング1日)

---

## 12. 次のステップ

1. **[実装ガイド](./phase10-implementation.md) を確認する**
2. **Step 0: 依存方向の確定**から開始する
3. **各ステップ完了時にテストを実行し、動作確認を行う**
4. **全ステップ完了後に最終レビューを行う**

---

**更新履歴**:

- v2.0 (2026-01-19): 基本方針と詳細実装を分離、ゼロベースで再整理
- v1.0 (2026-01-19): Phase 9 として初版作成（Phase 11 から移動）
