# ADR-0004: ハイブリッドセッション管理の採用

**ステータス**: Accepted

**日付**: 2026-01-14

**決定者**: kotonoha-bot 開発チーム

## コンテキスト

Discord Bot で会話履歴を管理する必要がある。以下の要件を満たす必要がある:

1. **高速アクセス**: ユーザーのメッセージに即座に応答するため、会話履歴へのアクセスは高速である必要がある（目標: 100ms 以内）
2. **永続化**: Bot が再起動してもセッションと会話履歴が失われないようにする必要がある
3. **スケーラビリティ**: 複数のユーザーが同時に利用できる必要がある（目標: 100 セッション）
4. **データ損失の防止**: システム障害時にもデータが失われないようにする必要がある

## 決定

**SQLite（永続化層）と ChatSession（メモリ層）のハイブリッド管理**を採用する。

### アーキテクチャ

```txt
┌─────────────────────────────────┐
│   ChatSession (メモリ層)         │
│   - アクティブセッションを保持   │
│   - O(1)の高速アクセス           │
│   - 最大100セッションまで        │
└──────────┬──────────────────────┘
           │ 同期
           │ ├─ リアルタイム同期（重要な会話）
           │ ├─ バッチ同期（5分ごと）
           │ └─ セッション終了時
           ↓
┌─────────────────────────────────┐
│   SQLite (永続化層)              │
│   - 全セッションを永続化         │
│   - 会話履歴を完全保存           │
│   - ボット再起動時に復元         │
└─────────────────────────────────┘
```

## 理由

### 1. パフォーマンスと永続化の両立

- **メモリ層**: O(1)の高速アクセス、3 秒以内の応答を実現
- **永続化層**: データ損失を防止、ボット再起動時に復元

### 2. 段階的な同期戦略

- **リアルタイム同期**: 重要な会話（スレッドアーカイブ時など）
- **バッチ同期**: 5 分ごとにアイドル状態のセッションを自動保存
- **セッション終了時**: 必ず SQLite に保存

### 3. メモリ効率

- LRU キャッシュで古いセッションをメモリから削除
- 最大 100 セッションまでメモリ保持
- 非アクティブセッションは SQLite のみに保存

### 4. シンプルな実装

- SQLite は標準ライブラリで利用可能
- セットアップ不要、単一ファイルで管理
- トランザクション処理が簡単

## 代替案

### 代替案 A: メモリのみ（永続化なし）

**メリット**:

- 実装が最も簡単
- 最高速のアクセス速度
- セットアップ不要

**デメリット**:

- Bot の再起動で全データ消失
- システム障害時にデータ損失
- 運用上のリスクが高い

**採用しなかった理由**:

- **データ損失のリスクが受け入れられない**
- 場面緘黙支援では継続的な会話が重要
- 会話履歴が失われるとユーザー体験が大幅に低下

---

### 代替案 B: SQLite のみ（メモリキャッシュなし）

**メリット**:

- 完全な永続化
- データ損失のリスクが低い
- 実装がシンプル

**デメリット**:

- 毎回ディスク I/O が発生（遅い）
- 応答時間の目標（3 秒以内）を達成できない可能性
- スケーラビリティに問題

**採用しなかった理由**:

- **パフォーマンス要件を満たせない**
- ディスク I/O が応答時間に直接影響
- ユーザー体験が悪化

---

### 代替案 C: PostgreSQL/MySQL

**メリット**:

- 本格的なデータベース
- 高いスケーラビリティ
- 複雑なクエリに対応
- マルチサーバー対応可能

**デメリット**:

- セットアップが複雑（別プロセスが必要）
- Synology NAS 上での運用が煩雑
- 小規模プロジェクトには over-engineering
- リソース消費が大きい

**採用しなかった理由**:

- **シンプルさを優先**
- 単一サーバー運用で SQLite で十分
- セットアップの複雑さが運用コストを増やす
- 将来的にスケールが必要になった場合に移行を検討

---

### 代替案 D: Redis

**メリット**:

- 高速なインメモリデータベース
- 永続化オプションあり（RDB/AOF）
- セッション管理に適している
- TTL（自動削除）機能

**デメリット**:

- 別プロセスとして実行が必要
- セットアップが複雑
- メモリ使用量が大きい
- Synology NAS での運用が煩雑

**採用しなかった理由**:

- **セットアップの複雑さ**
- 追加のプロセス管理が必要
- SQLite のハイブリッド管理で同等のパフォーマンスを実現可能
- 運用コストが増加

---

## 結果

### メリット

1. **高速アクセス**: メモリ層で O(1)、100ms 以内のアクセス
2. **データ永続化**: SQLite 層でデータ損失を防止
3. **スケーラビリティ**: 100 セッションまで効率的に管理
4. **シンプルな実装**: SQLite は標準ライブラリ、セットアップ不要
5. **柔軟な同期戦略**: リアルタイム、バッチ、終了時の 3 つの同期方法
6. **リソース効率**: LRU キャッシュでメモリ使用量を最適化

### デメリット

1. **複雑性の増加**: 同期ロジックの実装が必要
2. **同期のタイミング**: 適切なタイミングで同期する必要がある
3. **データ不整合のリスク**: 同期失敗時の不整合に注意が必要

### トレードオフ

- **パフォーマンス vs 永続化**: 両方を実現するため複雑性が増加
- **メモリ使用量 vs アクセス速度**: 100 セッションまでメモリ保持
- **シンプルさ vs 機能**: ハイブリッド管理で適度なバランス

### 実装への影響

1. **SessionManager クラス**: メモリと SQLite の同期を管理
2. **ChatSession クラス**: メモリ内のセッションを表現
3. **同期戦略の実装**:
   - リアルタイム同期: スレッドアーカイブ時など
   - バッチ同期: 5 分ごとのバックグラウンドタスク
   - セッション終了時: 24 時間非アクティブで自動保存
4. **LRU キャッシュ**: 古いセッションを自動削除
5. **復元機能**: ボット再起動時に SQLite から自動復元

### パフォーマンス目標

- セッション取得: **100ms 以内** ✓
- メッセージ追加: **10ms 以内** ✓
- SQLite 保存: **50ms 以内** ✓（非同期処理）
- 同時セッション数: **100 セッション** ✓

## 参考資料

- [database-design.md](../database-design.md)
- [detailed-design.md](../detailed-design.md)
- [requirements overview](../../requirements/overview.md#会話履歴管理)

---

**作成日**: 2026 年 1 月 14 日 1 月 15 日
**最終更新日**: 2026 年 1 月 14 日 1 月 15 日
