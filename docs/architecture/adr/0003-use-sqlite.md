# ADR-0003: SQLite の採用

**ステータス**: Accepted

**日付**: 2026-01-14

**決定者**: kotonoha-bot 開発チーム

## コンテキスト

Discord Bot で会話履歴とセッション情報を永続化する必要がある。以下の要件を満たす必要がある:

1. **永続化**: Bot が再起動してもデータが失われない
2. **シンプルさ**: セットアップが不要、運用が簡単
3. **軽量**: リソース消費が少ない
4. **単一サーバー運用**: マルチサーバー対応は不要
5. **ファイルベース**: バックアップが容易

## 決定

**SQLite** を採用する。

## 理由

### 1. シンプルさ

- Python 標準ライブラリに含まれている（`sqlite3`）
- セットアップが不要（別プロセスが不要）
- 単一ファイルでデータベースを管理
- 設定ファイルが不要

### 2. 軽量

- リソース消費が少ない
- メモリ使用量が小さい
- Synology NAS での運用に適している

### 3. ファイルベース

- 単一ファイル（`.db`）で管理
- バックアップが容易（ファイルをコピーするだけ）
- データの可搬性が高い

### 4. 十分な機能

- ACID トランザクションをサポート
- SQL 標準に準拠
- インデックス、外部キー制約などをサポート
- 小〜中規模のデータには十分な性能

### 5. 単一サーバー運用に最適

- マルチサーバー対応は不要
- 単一プロセスからのアクセスのみ
- 同時書き込みが少ない（Discord Bot の特性）

## 代替案

### 代替案 A: PostgreSQL

**メリット**:

- 本格的なリレーショナルデータベース
- 高いスケーラビリティ
- 複雑なクエリに対応
- マルチサーバー対応可能
- 同時書き込みに強い

**デメリット**:

- セットアップが複雑（別プロセスが必要）
- Synology NAS 上での運用が煩雑
- リソース消費が大きい
- 小規模プロジェクトには over-engineering

**採用しなかった理由**:

- **シンプルさを優先**
- 単一サーバー運用で SQLite で十分
- セットアップの複雑さが運用コストを増やす
- 将来的にスケールが必要になった場合に移行を検討

---

### 代替案 B: MySQL

**メリット**:

- 一般的なデータベース
- 豊富なドキュメント
- 実績がある

**デメリット**:

- セットアップが複雑（別プロセスが必要）
- Synology NAS 上での運用が煩雑
- SQLite で十分な機能を提供

**採用しなかった理由**:

- **シンプルさを優先**
- SQLite で十分な機能を提供
- セットアップの複雑さが運用コストを増やす

---

### 代替案 C: ファイルベース（JSON/CSV）

**メリット**:

- 最もシンプル
- セットアップが不要
- 人間が読みやすい

**デメリット**:

- トランザクション処理が困難
- 同時書き込みに弱い
- データ整合性の保証が困難
- クエリ機能が限定的

**採用しなかった理由**:

- **データ整合性を優先**
- トランザクション処理が必要
- 同時書き込みに対応できない

---

### 代替案 D: NoSQL（MongoDB など）

**メリット**:

- スキーマレスで柔軟
- 水平スケーリングが可能
- JSON 形式で扱いやすい

**デメリット**:

- セットアップが複雑
- リソース消費が大きい
- リレーショナルデータには不向き
- 小規模プロジェクトには over-engineering

**採用しなかった理由**:

- **シンプルさを優先**
- リレーショナルデータ構造が適している
- セットアップの複雑さが運用コストを増やす

---

## 結果

### メリット

1. **シンプルさ**: セットアップ不要、単一ファイルで管理
2. **軽量**: リソース消費が少ない
3. **永続化**: データ損失を防止
4. **バックアップ**: ファイルをコピーするだけ
5. **標準ライブラリ**: 追加の依存関係が不要

### デメリット

1. **スケーラビリティ**: 大規模な同時書き込みには不向き
2. **マルチサーバー対応**: 複数サーバーからの同時アクセスに弱い
3. **機能制限**: 一部の高度な機能が制限される

### トレードオフ

- **シンプルさ vs スケーラビリティ**: シンプルさを優先し、将来的な移行を検討
- **軽量 vs 機能**: 軽量を優先し、必要な機能は十分に提供

### 実装への影響

1. **データベース設計**: SQLite の制約を考慮したテーブル設計
2. **非同期処理**: `aiosqlite` を使用して非同期アクセス
3. **バックアップ戦略**: 定期的なファイルバックアップ
4. **移行計画**: 将来的に PostgreSQL への移行を検討（必要に応じて）

### 将来の移行

スケールが必要になった場合、以下の移行パスを検討:

1. **PostgreSQL への移行**: マルチサーバー対応が必要になった場合
2. **抽象化レイヤー**: データベースアクセスを抽象化し、移行を容易にする
3. **段階的移行**: データ移行ツールを作成し、ダウンタイムを最小化

## 参考資料

- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [aiosqlite Documentation](https://aiosqlite.omnilib.dev/)
- [database-design.md](../database-design.md)
- [middleware-selection.md](../../implementation/middleware-selection.md)
- [ADR-0004: ハイブリッドセッション管理](./0004-hybrid-session-management.md)

---

**作成日**: 2026 年 1 月 14 日
**最終更新日**: 2026 年 1 月 14 日
