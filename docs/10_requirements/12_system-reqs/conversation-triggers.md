# 会話の契機の詳細説明

Kotonoha は、ユーザーの使い方に応じて 3 つの会話方式をサポートします。

## 1. メンション応答型（基本）

**挙動:**

- ユーザーが Bot にメンション（@BotName）を送った時だけ反応
- 例: ユーザー「@Kotonoha こんにちは」→ Bot「こんにちは！」

**メリット:**

- 必要な時だけ呼び出せるので、他の会話の邪魔にならない
- 実装がシンプル（`on_message` イベントでメンション判定するだけ）

**デメリット:**

- 毎回 @ を打つのが面倒
- 会話が長引くとタイムラインが Bot の返信で埋め尽くされる

**履歴管理:**

- セッションキー: `mention:{user_id}`
- ユーザーごとに会話履歴を管理

**実装箇所**: `src/kotonoha_bot/bot/handlers.py` (150-251 行目)

---

## 2. スレッド型（AI チャットに最適）⭐ **推奨**

**挙動:**

- **ユーザーはメンションするだけ**: メインチャンネルで「@Kotonoha 今日は何月？」とメンション
- **Bot が自動でスレッドを作成**: Bot がその発言を起点として、自動的にスレッドを作成
- **Bot がスレッド内で応答**: 「現在は 1 月です（ここからはスレッドで話しましょう）」と返事
- **継続**: ユーザーはスレッド内で会話を続ける（もうメンションは不要）
- **ユーザー体験**: 「メンションしたら勝手に個室（スレッド）が用意された」という感覚

**技術的な理由（なぜスレッドが必須か）:**

- **会話履歴の取得が簡単**: スレッド内のメッセージを取得するだけで、その話題に関係する発言だけが純粋に取れる
- **コンテキストの分離**: メインチャンネルの他の話題と混ざらないため、Bot が混乱しない
- **スレッド内での会話**: スレッドはパブリックなので、他のユーザーも参加できる。
  スレッド内での会話はその話題に限定されるため、メインチャンネルの他の話題と混ざらない
- **スレッドがない場合の問題**: メインチャンネルで混ざって会話すると、Bot は「どれが自分宛てで、どれが関係ない雑談か」を判断できず、トンチンカンな発言をするリスクがある

**メリット:**

- メインのチャンネルを汚さない
- 「会話の区切り」が明確（スレッド ID = 1 つの会話セッションとして履歴管理しやすい）
- スレッドをアーカイブ（閉じる）すれば、会話終了も明確
- 場面緘黙支援に最適（プライベートな会話空間を提供）
- **ユーザーは手動でスレッドを作る必要がない**（Bot が自動化）

**デメリット:**

- Bot 側のスレッド作成処理が必要（ただし、ユーザーには見えない）

**履歴管理:**

- スレッド ID をセッションキーとして使用
- セッションキー: `thread:{thread_id}`
- スレッドアーカイブ時にセッションを SQLite に保存

**実装箇所**: `src/kotonoha_bot/bot/handlers.py` (253-567 行目)

**スレッド名の生成:**

- ユーザーの質問から端的で短い名前を自動生成（最大 50 文字）
- メンション部分を除去したメッセージから生成
- 改行文字や制御文字を除去し、複数の空白を 1 つにまとめる
- 文の区切り（。、！、？、.、!、?）で切る
- メンションのみや空白のみの場合は「会話」をデフォルト名として使用
- **固定スレッド名**: 一度設定したスレッド名は固定で、以降は更新しない

**実装箇所**: `src/kotonoha_bot/bot/handlers.py` (316-338 行目)

**スレッドの自動アーカイブ:**

- 環境変数 `THREAD_AUTO_ARCHIVE_DURATION` で設定可能（分単位）
- 未設定の場合はサーバーのデフォルト値を使用
- 有効な値: 60 (1 時間)、1440 (1 日)、4320 (3 日)、
  10080 (7 日)、43200 (30 日)
- 例: `THREAD_AUTO_ARCHIVE_DURATION=60` で 1 時間に設定

**設定:**

- デフォルトで有効（すべてのチャンネルでスレッド型が有効）
- チャンネルごとに無効化可能（`thread_enabled_channels` で制御）

---

## 3. 聞き耳型（自然な会話参加）⭐ **場面緘黙支援に最適**

**挙動:**

- **「聞き耳を立てていて、話に入りたくなったら入ってくる」**という、人間と同じような挙動
- 技術的には**「常駐型（全てのメッセージを読み取る）」**だが、全てのメッセージに返信するのではなく、**「今、自分が発言すべきか？」という判断ロジック**を挟む
- 会話の流れを理解し、適切なタイミングで自然に会話に参加

**メリット:**

- 人間らしい自然な会話参加が可能
- 場面緘黙支援に最適（プレッシャーを感じさせず、自然な会話の流れを作る）
- ユーザーが積極的に話しかけなくても、会話に参加できる
- コミュニティの雰囲気を和らげる効果

**デメリット:**

- 全ての発言に対して判断処理が必要（API リクエストが増える）
- 実装がやや複雑
- 空気を読めないタイミングで発言するリスク

**実装アプローチ:**

Kotonoha は現在、**アプローチ 1（LLM 判定）のみを実装**しています。

### 3.1 アプローチ 1: LLM に「空気」を読ませる（実装済み・推奨）⭐

**重要な前提:**

- **スレッドを作らない**: メインチャンネルに直接書き込む
- **目的**: 「みんなの雑談に混ざること」が目的のため、スレッドを作ると会話の流れを切ってしまう
- **イメージ**: 「クラスの賑やかし役」として自然に会話に参加

**2 段階処理フロー:**

ユーザーが発言するたびに、Bot は以下のフローを実行します。

1. **受信**: ユーザーのメッセージを受け取る
2. **バッファ**: 直近の会話ログ（10〜20 件程度）に追加する
3. **判定フェーズ（裁判官）**:
   - 軽量な AI（Claude Haiku 4.5）にログを渡す
   - **「今、君が割り込むべき？ YES か NO で答えて」**と聞く
   - AI が「NO」と言った ➡ 何もしない（無視）
   - AI が「YES」と言った ➡ 発言生成フェーズへ
4. **発言生成フェーズ（演者）**:
   - 再度 AI にログを渡し、「返信文を作って」と依頼する
   - Discord のメインチャンネルに直接書き込む

**判定用プロンプトの重要性:**

判定用 AI への指示（プロンプト）が最も重要です。以下のような指示を毎回送ります。

**実装箇所**: `prompts/eavesdrop_judge_prompt.md`

**メリット:**

- かなり人間らしく、文脈に沿った「良いタイミング」で入ってこれる
- 場面緘黙支援に最適（自然な会話の流れを提供）
- **誤爆が少ない**: 単純なキーワード反応だと誤反応するが、LLM なら文脈で判断できる
- **圧倒的に「賢く」見える**: 文脈を理解して入ってくるので、ユーザーは「Bot に見守られている」感覚になる

**デメリット:**

- **レスポンスが少し遅れる**: 「判定」→「生成」と 2 回 AI を叩くため、返答までに 2〜4 秒程度かかる
- **API リクエスト数が増える**: 全てのメッセージに対して「判定」のリクエストを送るため、
  活発なサーバーだと無料枠の上限（2026 年 1 月現在: Gemini Flash なら 1 分間 5 回、
  1 日 20 回）に引っかかりやすい
- **記憶の混濁（コンテキストのノイズ）**: メインチャンネルで複数の話題が混ざると、
  Bot が混乱しやすく、トンチンカンな発言をするリスクが少し高まる
  （スレッド型なら話題ごとに部屋が分かれるのでこの問題は起きない）

**技術仕様:**

- **判断用 AI**: Claude Haiku 4.5（デフォルト、
  `EAVESDROP_JUDGE_MODEL` 環境変数で変更可能）
- **会話ログ保持**: 直近 20 件のメッセージ（`EAVESDROP_BUFFER_SIZE` 環境変数で変更可能、デフォルト: 20）
- **最小メッセージ数**: 判定・応答生成に必要な最低メッセージ数（`EAVESDROP_MIN_MESSAGES` 環境変数で変更可能、デフォルト: 3）
- **最小介入間隔**: 10 分
  （`EAVESDROP_MIN_INTERVENTION_INTERVAL_MINUTES` 環境変数で変更可能、
  デフォルト: 10）
- **判断プロンプト**: Yes/No のみの簡潔な応答を要求（判定用プロンプトの最適化が重要）
- **応答生成**: 判断が「YES」の場合のみ、通常の AI 応答を生成
- **発言場所**: メインチャンネルに直接書き込む（スレッドは作成しない）

**実装箇所**: `src/kotonoha_bot/eavesdrop/llm_judge.py`

**介入判定の最適化:**

- 最小介入間隔チェック（10 分以内の判定はスキップ）
- 同じ会話判定のキャッシュ（5 分間有効）
- 会話状態の分析（終了、誤解、対立、アクティブなど）
- 会話状況の変化判定（介入後の会話状況が変わったか）

詳細は [介入改善の実装](./intervention_improvements.md) を参照してください。

### 3.2 アプローチ 2: ルールベースと確率（未実装）

**重要な前提:**

- **スレッドを作らない**: アプローチ 1 と同様に、メインチャンネルに直接書き込む
- **目的**: 省エネ・高速な判断が必要な場合に使用
- **実装状況**: 現在は未実装（将来の拡張として検討）

**仕組み（予定）:**

- **キーワード検知**: 「Bot」「誰か」「教えて」「助けて」などの単語が含まれていたら 50%の確率で反応する
- **盛り上がり検知**: 「1 分間に 5 件以上の投稿があったら（盛り上がっていると判断して）、挨拶する」
- **ランダム**: 全てのメッセージに対して、3%～ 5%の確率で勝手にリプライする

**メリット:**

- API を無駄遣いしない（判定用の API リクエストが不要）
- 実装が簡単
- 高速な判断が可能（プログラム側で即座に判定）

**デメリット:**

- 文脈を無視して入ってくるので、シリアスな話をしている時に「ウケるｗ」とか言ってしまい、空気が読めない（KY な）Bot になるリスクがある
- 場面緘黙支援には不向き（不適切なタイミングで発言する可能性）
- **記憶の混濁**: アプローチ 1 と同様に、メインチャンネルで複数の話題が混ざると混乱しやすい

**履歴管理:**

- チャンネルごとの会話ログを一時保存（直近 10〜20 件）
- セッションキー: `eavesdrop:{channel_id}`
- 判断ログは保存しない（判断のみで、会話履歴には含めない）
- **発言場所**: メインチャンネルに直接書き込む（スレッドは作成しない）

**設定:**

- チャンネルごとに有効/無効を設定可能（`EAVESDROP_ENABLED_CHANNELS` 環境変数で設定）
- 現在はアプローチ 1（LLM 判定）のみ実装

**実装箇所**: `src/kotonoha_bot/eavesdrop/conversation_buffer.py`,
`src/kotonoha_bot/bot/handlers.py` (619-723 行目)

---

## 4. スレッド型と聞き耳型の比較

| 特徴                   | スレッド型（AI チャット）                        | 聞き耳型（空気を読む）                               |
| ---------------------- | ------------------------------------------------ | ---------------------------------------------------- |
| **イメージ**           | 「相談窓口 / カウンター」                        | 「クラスの賑やかし役」                               |
| **Bot の発言場所**     | 作成されたスレッドの中だけ                       | メインのタイムラインに直接                           |
| **スレッド作成**       | Bot が自動で作成（ユーザーはメンションするだけ） | スレッドを作らない                                   |
| **会話の続き方**       | スレッド内の発言なら、Bot は無条件で返信する     | Bot は毎回「また自分が答えるべきか？」を再度判定する |
| **記憶(コンテキスト)** | そのスレッド内の会話ログだけを読み込む           | チャンネルの「直近 ○ 件」を常に読み込む              |
| **主な用途**           | Q&A、相談、ロールプレイ、作業支援                | 雑談、ツッコミ、盛り上げ役                           |
| **場面緘黙支援**       | プライベートな会話空間を提供                     | 自然な会話の流れを作る                               |
| **コンテキストの分離** | 話題ごとに部屋が分かれるので混濁しない           | 複数の話題が混ざると混乱しやすい                     |

---

## 5. 実装の詳細

### 5.1 メッセージルーティング

**実装箇所**: `src/kotonoha_bot/router/message_router.py`

メッセージは以下の順序で判定されます：

1. **Bot 自身のメッセージ**: 無視（`message.author.bot` が `True` の場合）
2. **メンション応答型の判定**: Bot がメンションされている場合
   - スレッド型が有効な場合 → スレッド型として処理
   - スレッド型が無効な場合 → メンション応答型として処理
3. **スレッド型の判定**: 既存スレッド内での会話の場合
   - Bot が作成したスレッドか確認
   - Bot が作成したスレッドの場合 → スレッド型として処理
4. **聞き耳型の判定**: 聞き耳型が有効なチャンネルか確認
   - 有効なチャンネルの場合 → 聞き耳型として処理
5. **その他**: 処理しない（`none` を返す）

### 5.2 セッションキーの形式

| 会話の契機 | セッションキー形式       | 例                    |
| ---------- | ------------------------ | --------------------- |
| メンション | `mention:{user_id}`      | `mention:123456789`   |
| スレッド   | `thread:{thread_id}`     | `thread:987654321`    |
| 聞き耳型   | `eavesdrop:{channel_id}` | `eavesdrop:111222333` |

**実装箇所**: `src/kotonoha_bot/bot/handlers.py`

### 5.3 環境変数による設定

**スレッド型の設定**:

```env
# スレッドの自動アーカイブ期間（分）
# 未設定の場合はサーバーのデフォルト値を使用
# 有効な値: 60 (1時間), 1440 (1日), 4320 (3日), 10080 (7日), 43200 (30日)
THREAD_AUTO_ARCHIVE_DURATION=60
```

**聞き耳型の設定**:

```env
# 聞き耳型を有効にするチャンネルID（カンマ区切り）
EAVESDROP_ENABLED_CHANNELS=123456789012345678,987654321098765432

# 判定用モデル（デフォルト: anthropic/claude-haiku-4-5）
EAVESDROP_JUDGE_MODEL=anthropic/claude-haiku-4-5

# バッファサイズ（デフォルト: 20）
EAVESDROP_BUFFER_SIZE=20

# 最小メッセージ数（デフォルト: 3）
EAVESDROP_MIN_MESSAGES=3

# 最小介入間隔（分、デフォルト: 10）
EAVESDROP_MIN_INTERVENTION_INTERVAL_MINUTES=10
```

**実装箇所**: `src/kotonoha_bot/config.py` (58-88 行目)

---

**作成日**: 2026 年 1 月 14 日  
**最終更新日**: 2026 年 1 月（現在の実装に基づいて改訂）  
**バージョン**: 2.0  
**作成者**: kotonoha-bot 開発チーム

### 更新履歴

- **v2.0** (2026-01): 現在の実装に基づいて改訂
  - セッションキーの形式を実装に合わせて更新
  - スレッド名の生成ロジックを実装に合わせて更新
  - 聞き耳型の判定モデルを実装に合わせて更新（Claude Haiku 4.5）
  - バッファサイズ、最小メッセージ数、最小介入間隔の実装値を反映
  - ルールベース判定が未実装であることを明記
  - 実装箇所の参照を追加
  - 環境変数による設定方法を追加
- **v1.0** (2026-01-14): 初版リリース
